"""
Webintegration f√∂r AI Affiliate Platform
Enkel JavaScript-baserad integration med ML-modulen
"""

import json
import os
from datetime import datetime
import subprocess
import sys


def generate_market_data_for_web():
    """Genererar marknadsdata f√∂r webben fr√•n ML-modulen"""

    try:
        # Importera ML-modulen
        from local_market_ml import LocalMarketMLAnalyzer

        # Skapa ML-instans med alla 15 l√§nder
        ml_analyzer = LocalMarketMLAnalyzer()
        print(f"‚úÖ Analyserade {len(ml_analyzer.target_countries)} marknader")

        # Generera data f√∂r alla l√§nder
        country_data = {}

        # Country flag mappning
        country_flags = {
            "SE": "üá∏üá™", "NO": "üá≥üá¥", "DK": "üá©üá∞", "FI": "üá´üáÆ", "DE": "üá©üá™",
            "NL": "üá≥üá±", "FR": "üá´üá∑", "GB": "üá¨üáß", "US": "üá∫üá∏", "AU": "üá¶üá∫",
            "IT": "üáÆüáπ", "ES": "üá™üá∏", "PL": "üáµüá±", "JP": "üáØüáµ", "CA": "üá®üá¶"
        }

        country_names = {
            "SE": "Sverige", "NO": "Norge", "DK": "Danmark", "FI": "Finland", "DE": "Tyskland",
            "NL": "Nederl√§nderna", "FR": "Frankrike", "GB": "Storbritannien", "US": "USA", "AU": "Australien",
            "IT": "Italien", "ES": "Spanien", "PL": "Polen", "JP": "Japan", "CA": "Kanada"
        }

        best_potential = 0
        best_country = "SE"

        for country in ml_analyzer.target_countries:
            market = ml_analyzer.market_data.get(country, {})
            culture = ml_analyzer.cultural_insights.get(country, {})

            # Ber√§kna potentialpo√§ng
            potential_score = int(
                market.get("ecommerce_penetration", 0.5) * 50 +
                market.get("gdp_per_capita", 20000) / 1000 +
                (1 - culture.get("language_barrier", 0.5)) * 30
            )

            if potential_score > best_potential:
                best_potential = potential_score
                best_country = country_names.get(country, country)

            # Kulturella faktorer
            design_map = {
                "minimalist": "Minimalistisk",
                "functional": "Funktionell",
                "hygge": "Hygge/Komfort",
                "engineering": "Engineering/Kvalitet",
                "casual_practical": "Avslappnad/Praktisk",
                "elegant_stylish": "Elegant/Stilfull",
                "vibrant_expressive": "Livfull/Uttrycksfull",
                "practical_value": "Praktisk/V√§rde",
                "minimalist_precise": "Minimalistisk/Precis",
                "friendly_reliable": "V√§nlig/P√•litlig"
            }

            behavior_map = {
                "research_heavy": "Forskande",
                "quality_focused": "Kvalitetsfokuserad",
                "balanced": "Balanserad",
                "tech_savvy": "Teknikmedveten",
                "thorough_research": "Grundlig forskning",
                "outdoor_focused": "Utomhusfokuserad",
                "fashion_conscious": "Modemedveten",
                "social_influenced": "Socialt p√•verkad",
                "value_seeking": "V√§rdejagande",
                "detail_oriented": "Detaljorienterad",
                "research_conscious": "Forskningsmedveten"
            }

            # Hitta toppm√•nader
            seasonal = market.get("seasonal_shopping", [1.0] * 12)
            peak_months = []
            avg_seasonal = sum(seasonal) / len(seasonal)

            month_names = ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun",
                           "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"]

            for i, value in enumerate(seasonal):
                if value > avg_seasonal * 1.1:
                    peak_months.append(month_names[i])

            country_data[country] = {
                "name": country_names.get(country, country),
                "flag": country_flags.get(country, "üè≥Ô∏è"),
                "potential_score": potential_score,
                "ecommerce_penetration": int(market.get("ecommerce_penetration", 0.5) * 100),
                "mobile_usage": int(market.get("mobile_shopping_ratio", 0.5) * 100),
                "price_sensitivity": int(culture.get("price_sensitivity", 0.5) * 100),
                "cultural_factors": {
                    "design": design_map.get(culture.get("design_preference", ""), "Ok√§nd"),
                    "trust": ", ".join(culture.get("trust_factors", ["Kvalitet"])[:2]),
                    "behavior": behavior_map.get(culture.get("shopping_behavior", ""), "Balanserad"),
                    "language_barrier": int(culture.get("language_barrier", 0.5) * 100)
                },
                "seasonal_trend": seasonal,
                "peak_months": ", ".join(peak_months) if peak_months else "J√§mn f√∂rdelning",
                "popular_categories": market.get("popular_categories", ["elektronik"])[:5],
                "payment_methods": market.get("payment_methods", ["kort"])[:3],
                "competitors": ml_analyzer.identify_local_competitors(country, "elektronik")[:4]
            }

        market_data = {
            "timestamp": datetime.now().isoformat(),
            "overall_score": best_potential,
            "best_category": "elektronik",
            "best_market": best_country,
            "countries": country_data
        }

        print(f"üèÜ B√§sta marknad: {best_country} ({best_potential}%)")
        print(f"üìà B√§sta kategori: elektronik")

        return market_data

    except Exception as e:
        print(f"‚ö†Ô∏è Fel vid generering av marknadsdata: {e}")
        print(f"üîÑ Anv√§nder fallback-data...")
        return generate_static_fallback_data()


def generate_static_fallback_data():
    """Fallback-data om ML-modulen misslyckas"""
    return {
        "timestamp": datetime.now().isoformat(),
        "overall_score": 85,
        "best_category": "elektronik",
        "best_market": "Sverige",
        "countries": {
            "SE": {
                "name": "Sverige",
                "flag": "üá∏üá™",
                "potential_score": 88,
                "ecommerce_penetration": 84,
                "mobile_usage": 65,
                "price_sensitivity": 65,
                "cultural_factors": {
                    "design": "Minimalistisk",
                    "trust": "Recensioner, H√•llbarhet",
                    "behavior": "Forskande",
                    "language_barrier": 15
                },
                "seasonal_trend": [0.8, 0.7, 0.9, 1.0, 0.9, 0.7, 0.6, 0.7, 0.9, 1.1, 1.3, 1.5],
                "peak_months": "Nov-Dec",
                "popular_categories": ["elektronik", "mode", "sport", "hem", "b√∂cker"],
                "payment_methods": ["Swish", "Kort", "Klarna"],
                "competitors": ["Elgiganten", "H&M", "Stadium", "IKEA"]
            }
        }
    }


def generate_ai_recommendations():
    """Genererar AI-rekommendationer baserat p√• marknadsdata"""

    try:
        from local_market_ml import LocalMarketMLAnalyzer

        ml_analyzer = LocalMarketMLAnalyzer()

        # Test produktdata
        test_product = {
            'id': 'test_001',
            'name': 'Tr√•dl√∂sa H√∂rlurar Pro',
            'platform': 'amazon',
            'category': 'elektronik',
            'price': 599,
            'rating': 4.5,
            'reviews': 1250
        }

        print("üîç Testar produktanalys...")

        # Analysera produkten f√∂r alla marknader
        best_score = 0
        best_market = "SE"

        for country in ml_analyzer.target_countries[:5]:  # Test f√∂rst 5 l√§nder
            try:
                score = ml_analyzer.score_product_for_local_market(
                    test_product, country)
                total_score = (score.local_appeal_score +
                               score.cultural_fit_score) / 2 * 100

                if total_score > best_score:
                    best_score = total_score
                    best_market = country
            except:
                continue

        print(
            f"‚úÖ Produktanalys slutf√∂rd - √ñvergripande po√§ng: {best_score:.1f}%")
        print(f"üéØ B√§sta marknad f√∂r produkten: {best_market}")

        recommendations = [
            "Fokusera p√• elektronik-kategorin f√∂r b√§sta resultat",
            f"Prioritera {best_market}-marknaden f√∂r nya produkter",
            "Anv√§nd s√§songsdata f√∂r optimal timing av kampanjer",
            "Anpassa produkttexter efter kulturella preferenser",
            "Optimera f√∂r mobil - majoriteten handlar via telefon"
        ]

        print("üí° Genererar AI-rekommendationer...")
        print(f"‚úÖ {len(recommendations)} rekommendationer genererade")

        return recommendations

    except Exception as e:
        print(f"‚ö†Ô∏è Fel vid AI-rekommendationer: {e}")
        return [
            "Fokusera p√• popul√§ra kategorier som elektronik och mode",
            "Optimera f√∂r mobila enheter",
            "Anv√§nd lokala betalningsmetoder",
            "Anpassa inneh√•ll efter s√§songsvariation",
            "Fokusera p√• marknader med l√•g spr√•kbarri√§r"
        ]


def test_product_analysis(product_data, target_country="SE"):
    """Testar produktanalys f√∂r specifik marknad"""

    try:
        from local_market_ml import LocalMarketMLAnalyzer

        ml_analyzer = LocalMarketMLAnalyzer()
        result = ml_analyzer.score_product_for_local_market(
            product_data, target_country)

        return {
            "overall_score": round((result.local_appeal_score + result.cultural_fit_score) / 2 * 100, 1),
            "local_appeal": round(result.local_appeal_score * 100, 1),
            "cultural_fit": round(result.cultural_fit_score * 100, 1),
            "predicted_clicks": int(result.predicted_local_clicks),
            "predicted_revenue": round(result.predicted_local_revenue, 2),
            "recommendations": result.marketing_recommendations[:3]
        }

    except Exception as e:
        print(f"Fel vid produktanalys: {e}")
        return {
            "overall_score": 75.0,
            "local_appeal": 80.0,
            "cultural_fit": 70.0,
            "predicted_clicks": 150,
            "predicted_revenue": 1250.0,
            "recommendations": ["Optimera f√∂r lokala preferenser", "Fokusera p√• mobil", "Anv√§nd lokala betalningar"]
        }


def save_market_data_js(market_data, ai_recommendations):
    """Sparar marknadsdata som JavaScript-fil"""

    js_content = f'''// AI Affiliate Platform - Marknadsdata
// Auto-genererad: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

window.MarketData = {json.dumps(market_data, indent=2, ensure_ascii=False)};

window.AIRecommendations = {json.dumps(ai_recommendations, indent=2, ensure_ascii=False)};

// Hj√§lpfunktioner f√∂r AI-analys
window.AIAnalyzer = {{
    
    // Analysera produkt f√∂r specifik marknad
    analyzeProduct: function(productData, targetCountry = "SE") {{
        console.log("ü§ñ Analyserar produkt f√∂r marknad:", targetCountry);
        
        const country = MarketData.countries[targetCountry];
        if (!country) {{
            console.warn("Ok√§nd marknad:", targetCountry);
            return null;
        }}
        
        // Enkel scoring baserat p√• marknadsdata
        let score = 70; // Baspo√§ng
        
        // Justera baserat p√• e-handel penetration
        score += country.ecommerce_penetration * 0.2;
        
        // Justera f√∂r prisk√§nslighet
        score += (100 - country.price_sensitivity) * 0.1;
        
        // Justera f√∂r spr√•kbarri√§r
        score += (100 - country.cultural_factors.language_barrier) * 0.15;
        
        // Begr√§nsa till 0-100
        score = Math.min(Math.max(score, 0), 100);
        
        return {{
            country: targetCountry,
            country_name: country.name,
            overall_score: Math.round(score * 10) / 10,
            market_potential: country.potential_score,
            cultural_fit: Math.round((score + country.potential_score) / 2 * 10) / 10,
            recommendations: [
                `Anpassa f√∂r ${{country.cultural_factors.design.toLowerCase()}} design`,
                `Fokusera p√• ${{country.cultural_factors.trust.toLowerCase()}}`,
                `Optimera f√∂r ${{country.payment_methods.join(", ").toLowerCase()}}`
            ]
        }};
    }},
    
    // Hitta b√§sta marknader f√∂r produkt
    findBestMarkets: function(productData, topN = 5) {{
        const results = [];
        
        for (const [countryCode, country] of Object.entries(MarketData.countries)) {{
            const analysis = this.analyzeProduct(productData, countryCode);
            if (analysis) {{
                results.push(analysis);
            }}
        }}
        
        // Sortera efter po√§ng
        results.sort((a, b) => b.overall_score - a.overall_score);
        
        return results.slice(0, topN);
    }},
    
    // F√• s√§songsrekommendationer
    getSeasonalInsights: function(countryCode = "SE") {{
        const country = MarketData.countries[countryCode];
        if (!country) return null;
        
        const months = ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", 
                       "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"];
        
        const seasonal = country.seasonal_trend;
        const max = Math.max(...seasonal);
        const bestMonth = seasonal.indexOf(max);
        
        return {{
            country: countryCode,
            best_month: months[bestMonth],
            peak_months: country.peak_months,
            seasonal_data: seasonal
        }};
    }}
}};

// Exportera f√∂r konsol-access
console.log("ü§ñ AI Affiliate Platform marknadsdata laddad!");
console.log("üìä Tillg√§ngliga marknader:", Object.keys(MarketData.countries).length);
console.log("üí° Anv√§nd AIAnalyzer.analyzeProduct(productData, 'SE') f√∂r analys");
'''

    try:
        with open('market_data.js', 'w', encoding='utf-8') as f:
            f.write(js_content)

        abs_path = os.path.abspath('market_data.js')
        print(f"üìä Marknadsdata sparad till: {abs_path}")
        return True

    except Exception as e:
        print(f"‚ùå Fel vid sparning av market_data.js: {e}")
        return False


def main():
    """Huvudfunktion f√∂r marknadsanalys"""

    print("ü§ñ AI Affiliate Platform - Marknadsanalys")
    print("=" * 50)

    # Generera marknadsdata
    print("üìä Genererar marknadsdata...")
    market_data = generate_market_data_for_web()

    # Generera AI-rekommendationer
    ai_recommendations = generate_ai_recommendations()

    # Spara som JavaScript
    print("üíæ Sparar data f√∂r webintegration...")
    if save_market_data_js(market_data, ai_recommendations):
        print("üéâ Analys slutf√∂rd!")
        print(
            "Nu kan du anv√§nda market_data.js i din webb f√∂r att komma √•t AI-funktionerna.")
    else:
        print("‚ùå Fel vid sparning - kontrollera filr√§ttigheter")


if __name__ == "__main__":
    main()
